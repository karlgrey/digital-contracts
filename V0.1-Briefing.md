0) Prerequisites

	•	Bestehendes Projekt respektieren (Node/Express, SQLite, PDFKit, Vanilla JS, bestehende Routen beibehalten, nur erweitern).
	•	Keine externen Services (keine Provider-Adapter, keine Webhooks).
	•	UI optisch vereinheitlichen gemäß Apple-Stil (Tokens, Cards, Segmented Buttons, Sticky Preis-Box).
	•	Fehlerbild einheitlich, mit klaren Feldhinweisen.
	•	Datenschutz: AGB/DSGVO-Hinweise verlinken, Checkbox erzwingen; Retention-Regel (z. B. Auto-Löschung alter Temp-PDFs, PII-Minimierung in Logs).

1) Ziel & Scope

Ziel: Dein bestehendes MVP so erweitern, dass es flexibel (Templates, Preise, Zeiträume) und bedienfreundlich (klarer Flow, Vorschau, Filter) ist — weiter nur intern für dich/Firma.

In Scope:
	1.	Vertrags-Templates (versioniert, Variablen)
	2.	Preislogik via Regeln + saisonale Overrides
	3.	Abrechnung: Pro-Rata, Kaution als Faktor, Kündigungsfrist
	4.	Einladungslinks (einmalig, optional vorbefüllt)
	5.	Vorschau vor Unterschrift + Terms-Hash ins PDF
	6.	Signatur-UX (Undo, Clear, Mindestqualität, Metadaten)
	7.	Admin: Filter, CSV-Export, Blackout-Zeiträume, Rabattcodes
	8.	Validierungsschicht, einfache Admin-Auth (JWT httpOnly), Rate-Limit
	9.	Audit-Log (wichtige Aktionen)
	10.	Betrieb: Healthcheck, WAL-Mode, Temp-Cleanup

Out of Scope:
– Fremd-Signaturanbieter/Provider-Adapter ❌
– Webhooks/Event-Outbox ❌


⸻

2) Abstrakte Datenstruktur (ohne SQL)

Beziehungsskizze (ERD) in Worten – Entities + Schlüsselattribute

	•	Company: Stammdaten der Vermieter (Name, Anschrift, Steuer/UST, Bank).
	•	Location (belongs to Company): Name, Adresse, Bereichsangabe.
	•	VehicleType: vordefinierte Größenklassen (Label, max_length).
	•	PricingRule (per Location×VehicleType×Kategorie): base_price, optional Gültigkeit (von/bis), Priorität.
	•	PricingOverride (saisonal): fester Preis, Zeitraum; greift vor Regeln.
	•	Discount: Code, Typ (Prozent/Betrag), Wert, optional Zeitraum, optional Location-Bindung, optional Nutzungslimit.
	•	LocationBlackout: Location, Zeitraum, Grund (nur Info).
	•	ContractTemplate (versioniert): Name, optional Scope (Company/Location), body_md, version, is_active.
	•	Booking: Kunde (Name, Adresse, E-Mail), Location, VehicleType, Kategorie, Zeitraum, berechnete Preise (monatlich, pro-rata, rabatt, kaution), Status (3-stufig), Referenzen auf template_id/version, terms_hash, Signaturfelder (Kunde/Vermieter + Timestamps), Metadaten (signer_ip, user_agent).
	•	InviteToken (optional): einmaliger, verfallender Token zur Vorbefüllung.
	•	AuditLog: actor, action, entity_type/id, metadata, timestamp.

Wesentliche Zustände (Booking.status):
pending_customer_signature → pending_owner_signature → completed.

⸻

3) Geschäftslogik & Regeln (präzise, ohne Code)

3.1 Preisfindung (Monatsmiete)

Eingaben: location_id, vehicle_type_id, category, atDate
	1.	Wenn Override existiert, dessen Zeitraum atDate enthält: override.price verwenden.
	2.	Sonst beste Regel mit passender Kombination + gültig in atDate, höchste Priorität gewinnt.
	3.	Wenn nichts passt: Fehler „NO_PRICE_RULE“.

3.2 Abrechnungskomponenten
	•	Monatsmiete: Ergebnis aus 3.1.
	•	Pro-Rata (falls billing_cycle = monthly): anteilig für den ersten Monat auf Basis Kalendertage.
	•	Kaution: deposit_multiplier × Monatsmiete (Default 2, änderbar pro Buchung).
	•	Rabatt:
	•	Typ „percent“ → preis * (1 - x/100)
	•	Typ „amount“ → preis - x, Minimum 0
	•	Nur gültig, wenn Code existiert, im Zeitraum liegt und (falls gesetzt) location_id passt und usage_limit nicht überschritten ist.

3.3 Verfügbarkeiten
	•	Blackouts: gewählte Start/Ende dürfen keine LocationBlackout-Intervalle schneiden → ansonsten Blocking im UI + Serverfehler.
	•	(Optional, später) Doppelte Buchung derselben Fläche ist hier kein Thema, da du keine Stellplatznummern nutzt.

3.4 Templates & Integrität
	•	Bei Erstellung einer Buchung: aktives Template wählen (Scope-Reihenfolge: Location → Company → Global).
	•	terms_hash = SHA256(body_md + version + company_id + location_id) (konzeptionell) wird mit der Buchung gespeichert und im PDF abgedruckt.
	•	PDF-Fußzeile: Contract-ID, Template-Name/Version, Terms-Hash (gekürzt), Erstellzeit.

3.5 Einladungslinks
	•	Einmaliger Token mit Ablauf; optional Vorbefüllung (location, vehicle, category, email).
	•	Token bei Aufruf validieren, bei Erfolg sofort invalidieren (One-shot).

3.6 Signatur-Qualität
	•	Canvas bietet Undo (letzter Strich) & Clear.
	•	Mindestkriterien: min. Anzahl Punkte/Striche und min. Bounding-Box-Fläche.
	•	Speichere signer_ip und user_agent.

3.7 Auth/Admin/Sicherheit
	•	Admin-Login: kurzer Token (ENV) → einmalig gegen httpOnly JWT eintauschen, Lebenszeit ca. 2h.
	•	Admin-Routen geschützt; Rate-Limit; CORS restriktiv; Cookies SameSite=strict, in Prod secure.
	•	Validierungsschicht: alle Eingaben gegen Schema validieren; einheitliches Fehlermodell.
	•	AuditLog für: Login/Logout, Template-Änderung, Preisregeln/Overrides anlegen/ändern, Blackouts, Discounts, Buchung erstellen/signieren, PDF erzeugen.

⸻

4) API-Verträge (sprachlich, ohne Payload-Code)

Public
	•	GET /api/locations → Liste nutzbarer Locations.
	•	GET /api/pricing/:locationId → Preisinformationen (oder leer, wenn Regeln/Overrides genutzt; optional: „ab“-Preise).
	•	GET /api/availability?location_id&from&to → Blackout-Intervalle (nur Zeiträume, keine Details).
	•	POST /api/bookings
Eingaben (konzeptionell): Auswahl (location, vehicle, category, dates), Kundendaten, Signatur-Bild, optional Rabattcode, Abrechnungsoptionen (billing_cycle, prorata_first_month, deposit_multiplier, notice_period_days).
Server: prüft Verfügbarkeit, ermittelt Preise, wählt Template, setzt terms_hash, sichert Signatur + Metadaten, legt Status pending_owner_signature.
Idempotenz: akzeptiert optionalen Header-Schlüssel (gleiche Eingabe → gleiche Buchung oder 409).
	•	GET /api/contract/:bookingId → PDF Vertrag (wenn pending_owner_signature/completed; bei pending_customer_signature ggf. Quittung/Entwurf).

Admin (JWT httpOnly erforderlich)
	•	Auth: POST /api/admin/auth/login, POST /api/admin/auth/logout.
	•	Dashboard: GET /api/admin/bookings?status&from&to&location_id, GET /api/admin/bookings/export.csv?...
	•	Owner-Sign: POST /api/admin/bookings/:id/sign-owner (setzt Signatur & Status → completed).
	•	Templates: GET /api/admin/templates, POST /api/admin/templates (legt neue Version an), PUT /api/admin/templates/:id/activate.
	•	Preise:
	•	Rules: GET/POST /api/admin/pricing/rules
	•	Overrides: GET/POST /api/admin/pricing/overrides
	•	Rabatte: GET/POST /api/admin/discounts
	•	Blackouts: GET/POST /api/admin/blackouts
	•	Health: GET /healthz

⸻

5) Nutzerfluss (User Journeys)

5.1 Kunde (Buchung)
	1.	Öffnet Formular (optional via Einladungslink mit Vorbefüllung).
	2.	Step „Auswahl“: Location, Größe, Kategorie, Datum (Blackouts gesperrt), optional Rabattcode.
	3.	Preis-Box zeigt: Monatsmiete, Pro-Rata (falls zutreffend), Rabatt, Kaution, Summe zum Start.
	4.	Step „Daten“: Adresse, E-Mail, AGB/Datenschutz bestätigen.
	5.	Step „Vorschau“: Vertrag (HTML) aus Template mit allen Platzhaltern.
	6.	Step „Signatur“: Unterschreiben, Mindestkriterien erfüllt, Absenden → Status pending_owner_signature.
	7.	Bestätigung: ruhige Erfolgsmeldung.

5.2 Admin (Freigabe)
	1.	Dashboard → neue Buchung (Filterbar).
	2.	Details prüfen → „Vermieter unterschreiben“.
	3.	Signatur setzen → Status completed.
	4.	PDF herunterladen/versenden.

⸻

6) UI-Beschreibung (Apple-Store-Stil)

Designprinzipien: ruhige Typografie, dezente Grau-Skala, großzügiger Weißraum, minimale Ablenkung, klare Hierarchien, sanfte 150–200 ms-Transitions.

Typo: Systemschrift (SF Pro / System UI).
Farben: Schwarz/Grau/Weiß; Akzentfarbe nur für interaktive Elemente (Links/Hover).
Ecken/Schatten: abgerundet (12–16 px), sehr leichte Schatten, dünne Divider.
Bedienung: klare Fokuszustände, Tastaturfähig, barrierearme Kontraste.

6.1 Booking
	•	Header (zentriert): Titel „Stellplatz buchen“, kurze Unterzeile (grau).
	•	Step 1 – Auswahl (Card):
	•	Location (Select mit Unterzeile = Adresse), Fahrzeuggröße (Select), Kategorie (Segmented Toggle: Außen/Überdacht/Halle), Zeitraum (Start/Ende; gesperrte Tage disabled), Rabattcode (kleines Feld mit „Einlösen“).
	•	Sticky Preis-Box: auf Desktop rechts, auf Mobile unterhalb: zeigt Breakdown (Monatsmiete, Pro-Rata, Rabatt, Kaution, Summe). Primärer „Weiter“-Button.
	•	Step 2 – Kundendaten (Card): klassische Adressfelder, E-Mail, AGB/Datenschutz-Checkbox mit dezenten Links.
	•	Step 3 – Vorschau (Card): scrollbarer Vertrag, sauberer Rand, Footerzeile mit Contract-ID, Template-Version, gekürztem Terms-Hash.
	•	Step 4 – Signatur (Card): großes Canvas, Buttons „Zurücksetzen“ & „Rückgängig“, Hinweis „Bitte mit vollem Namen unterschreiben“.
	•	Bestätigung: minimalistische Success-Seite.

Feedback/Fehler: inline, knapp, mit dezenter roter Outline; Skeletons statt Spinnern bei Laden.

6.2 Admin
	•	Top-Bar: links Produktname, rechts Tabs: Dashboard, Templates, Preise, Rabatte, Blackouts, Firmen, Standorte, Logout. Aktiver Tab mit feiner Unterstreichung.
	•	Dashboard:
	•	Filterleiste (Card): Von/Bis, Standort, Status, „Export CSV“.
	•	Tabelle (Card): Datum, Kunde, Standort, Größe/Kategorie, Status, Aktionen (Ansehen, PDF, Signieren).
	•	Stat-Kacheln: offene Unterschriften, Buchungen 30 Tage, Auslastung je Standort (kleine Balken).
	•	Templates: Liste mit Name, Scope (Global/Firma/Location), Version, Aktiv-Badge; Aktionen: „Neue Version“, „Aktiv setzen“, „Vorschau“.
	•	Preise: zwei Reiter: Regeln (Prioritäten, Gültigkeiten) und Overrides (Zeiträume, fester Preis).
	•	Rabatte: Liste + „Neuer Code“.
	•	Blackouts: Monatskalender ( klick-drag erzeugt Intervall ) + Liste.

⸻

7) Nichtfunktionale Anforderungen
	•	Performance: Preisauflösung < 50 ms; Buchungserstellung < 500 ms bei lokaler DB.
	•	Zuverlässigkeit: SQLite im WAL-Modus; tägliche Backups; Temp-PDF-Cleanup (> 30 Tage löschen).
	•	Sicherheit: Admin-JWT httpOnly, SameSite=strict; Rate-Limit auf Admin; HTTPS only in Prod.
	•	Validierung: jedes Eingabefeld serverseitig validiert; einheitliches Fehlermodell.
	•	Protokollierung: Audit-Log für kritische Aktionen; getrennte App/Access-Logs.

⸻

8) Akzeptanzkriterien (Tests, Black-Box)
	1.	Preislogik
	•	Override im Zeitraum schlägt Regel.
	•	Höhere Priorität gewinnt unter mehreren Regeln.
	•	Keine passende Regel/Override → Anfrage abgelehnt („NO_PRICE_RULE“).
	2.	Abrechnung
	•	Pro-Rata korrekt bei Start ≠ 1. des Monats (Kalendertage).
	•	Kaution = Faktor × Monatsmiete (Standard 2).
	•	Rabatt „10%“ vs. „25 €“ richtig angewandt; Minimum 0.
	3.	Verfügbarkeit
	•	Jeder Blackout im Intervall verhindert Buchung (UI + Server).
	4.	Templates
	•	Bei neuer Version erhöht sich die Versionsnummer automatisch; Aktivsetzen wirkt sich nur auf neue Buchungen aus.
	•	Terms-Hash wird in der Buchung gespeichert und im PDF angezeigt.
	5.	Signatur
	•	Unterschrift ohne Mindestfläche/Strichanzahl wird abgelehnt.
	•	Metadaten (IP, User-Agent) gespeichert.
	6.	Admin
	•	Geschützte Routen ohne JWT → 401.
	•	Filter (Zeitraum/Standort/Status) wirken auf Dashboard & CSV-Export.
	•	Owner-Sign wechselt den Status auf completed und aktiviert PDF-Download.
	7.	Betrieb
	•	/healthz gibt DB-Status „ok“ zurück.
	•	Temp-Cleanup löscht alte PDFs.
	•	Backups vorhanden.

⸻

9) Aufgabenpakete für eine KI (ohne Code, als To-Do-Blöcke)

Paket A – Struktur & Sicherheit
	•	Validierungsschicht für alle Public/Admin-Routen definieren.
	•	Admin-Auth: Login mit ENV-Token → Ausstellung httpOnly JWT; Logout; Middleware.
	•	Rate-Limit für /api/admin/*; restriktives CORS.

Paket B – Preis & Verfügbarkeit
	•	Resolver implementieren (Overrides > Regeln; Priorität; Gültigkeiten).
	•	Admin-Oberfläche für Regeln/Overrides (Erstellen/Listen/Ändern/Löschen).
	•	Public Availability-Endpoint; UI blockiert Blackout-Tage.

Paket C – Buchung & Abrechnung
	•	Buchungserstellung mit Pro-Rata, Kaution-Faktor, optional Rabattcode (Validierung).
	•	Idempotenz für POST /api/bookings.
	•	Einladungslink (einmalig, optional Vorbefüllung).

Paket D – Verträge
	•	Template-Verwaltung (Versionen, Aktiv-Setzen, Vorschau).
	•	Terms-Hash berechnen, in Booking speichern, im PDF anzeigen.
	•	Vorschau-Step (HTML) im Buchungsflow.

Paket E – Signatur-UX & Admin-Flows
	•	Canvas mit Undo/Clear; Mindestkriterien; Metadaten speichern.
	•	Admin: Dashboard-Filter, CSV-Export, Owner-Sign.

Paket F – Betrieb
	•	Healthcheck-Endpoint, WAL-Mode aktiv, Temp-Cleanup, Backups-Hinweis.
	•	Audit-Log an kritischen Stellen.
	•	Automatisierte Tests für Funktionalität und Performance.
